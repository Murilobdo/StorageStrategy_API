<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Commands/UpdateClientCommand.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Commands/UpdateClientCommand.cs" />
              <option name="originalContent" value="using StorageStrategy.Models;&#10;using MediatR;&#10;&#10;namespace StorageStrategy.Domain.Commands&#10;{&#10;    public class UpdateClientCommand : IRequest&lt;Result&gt;&#10;    {&#10;        public int ClientId { get; set; }&#10;        public int CompanyId { get; set; }&#10;        public string Name { get; set; }&#10;        public bool Active { get; set; }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Commands&#10;{&#10;    public class UpdateClientCommand : ClientCommand&#10;    {&#10;        public UpdateClientCommand(ClientEntity entity)&#10;        {&#10;            ClientId = entity.ClientId;&#10;            CompanyId = entity.CompanyId;&#10;            Name = entity.Name;&#10;            Active = entity.Active;&#10;        }&#10;&#10;        public UpdateClientCommand()&#10;        {&#10;            &#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Account/AccountHandlerBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Account/AccountHandlerBase.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using Microsoft.Extensions.Options;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Utils.Services;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Account;&#10;&#10;public class AccountHandlerBase : HandlerBase&#10;{&#10;    protected readonly IEmployeeRepository _repo;&#10;    protected readonly ICompanyRepository _repoCompany;&#10;    protected readonly IOptions&lt;AppSettings&gt; _appSettings;&#10;&#10;    public AccountHandlerBase(&#10;        IEmployeeRepository repo,&#10;        ICompanyRepository repoCompany,&#10;        IOptions&lt;AppSettings&gt; appSettings)&#10;    {&#10;        _repo = repo;&#10;        _repoCompany = repoCompany;&#10;        _appSettings = appSettings;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Account/ChangePasswordHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Account/ChangePasswordHandle.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using Isopoh.Cryptography.Argon2;&#10;using MediatR;&#10;using Microsoft.Extensions.Options;&#10;using StorageStrategy.Domain.Commands.Login;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;using StorageStrategy.Utils.Services;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Account;&#10;&#10;public class ChangePasswordHandle : AccountHandlerBase, IRequestHandler&lt;ChangePasswordCommand, Result&gt;&#10;{&#10;    public ChangePasswordHandle(&#10;        IEmployeeRepository repo,&#10;        ICompanyRepository repoCompany,&#10;        IOptions&lt;AppSettings&gt; appSettings) : base(repo, repoCompany, appSettings)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(ChangePasswordCommand request, CancellationToken cancellationToken)&#10;    {&#10;        var employee = await _repo.GetByIdAsync(request.UserId, request.CompanyId);&#10;&#10;        if(employee is null)&#10;            return CreateError(&quot;Funcionário não encontrado&quot;);&#10;&#10;        employee.PasswordHash = Argon2.Hash(request.NewPassword);&#10;&#10;        _repo.Update(employee);&#10;        await _repo.SaveAsync();&#10;&#10;        return CreateResponse(employee, &quot;Senha alterada com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Account/LoginHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Account/LoginHandle.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using Isopoh.Cryptography.Argon2;&#10;using MediatR;&#10;using Microsoft.Extensions.Options;&#10;using StorageStrategy.Domain.Commands.Login;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;using StorageStrategy.Utils.Services;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Account;&#10;&#10;public class LoginHandle : AccountHandlerBase, IRequestHandler&lt;LoginCommand, Result&gt;&#10;{&#10;    public LoginHandle(&#10;        IEmployeeRepository repo,&#10;        ICompanyRepository repoCompany,&#10;        IOptions&lt;AppSettings&gt; appSettings) : base(repo, repoCompany, appSettings)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(LoginCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        EmployeeEntity? employee = await _repo.FindByEmail(request.Email);&#10;&#10;        if (employee is null)&#10;            return CreateError(&quot;Email ou Senha incorreta&quot;);&#10;        &#10;        CompanyEntity company = await _repoCompany.GetById(employee.CompanyId);&#10;        &#10;        if (company.Validate &lt;= DateTime.Now)&#10;            return CreateError(&#10;                $&quot;Sua licenca expirou dia {company.Validate.ToShortDateString()}, entre em contato para renovação&quot;);&#10;&#10;        if (!Argon2.Verify(employee.PasswordHash, request.Password))&#10;            return CreateError(&quot;Email ou Senha incorreta&quot;);&#10;&#10;        TokenService tokenService = new TokenService();&#10;        string token = tokenService.GenerateToken(employee, _appSettings.Value.JwtKey);&#10;&#10;        employee.PasswordHash = string.Empty;&#10;&#10;        return CreateResponse(new&#10;        {&#10;            employee,&#10;            token&#10;        }, &quot;Login efetuado com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Category/CategoryHandlerBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Category/CategoryHandlerBase.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using StorageStrategy.Domain.Repository;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Category;&#10;&#10;public class CategoryHandlerBase : HandlerBase&#10;{&#10;    protected readonly ICategoryRepository _repo;&#10;    protected readonly IMapper _mapper;&#10;&#10;    public CategoryHandlerBase(ICategoryRepository repo, IMapper mapper)&#10;    {&#10;        _repo = repo;&#10;        _mapper = mapper;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Category/CreateCategoryHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Category/CreateCategoryHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Category;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Category;&#10;&#10;public class CreateCategoryHandle : CategoryHandlerBase, IRequestHandler&lt;CreateCategoryCommand, Result&gt;&#10;{&#10;    public CreateCategoryHandle(ICategoryRepository repo, IMapper mapper) : base(repo, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(CreateCategoryCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var category = await _repo.FindByName(request.Name, request.CompanyId);&#10;&#10;        if (category is not null)&#10;            return CreateError(&quot;Ja existe uma categoria com esse nome&quot;);&#10;&#10;        category = _mapper.Map&lt;CategoryEntity&gt;(request);&#10;&#10;        await _repo.AddAsync(category);&#10;        await _repo.SaveAsync();&#10;&#10;        return CreateResponse(category, &quot;Categoria cadastrada com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Category/DeleteCategoryHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Category/DeleteCategoryHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Category;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Category;&#10;&#10;public class DeleteCategoryHandle : CategoryHandlerBase, IRequestHandler&lt;DeleteCategoryCommand, Result&gt;&#10;{&#10;    public DeleteCategoryHandle(ICategoryRepository repo, IMapper mapper) : base(repo, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(DeleteCategoryCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var category = await _repo.GetById(request.CategoryId);&#10;&#10;        if (category is null)&#10;            return CreateError(&quot;Categoria não encontrada para exclusão&quot;);&#10;&#10;        _repo.Delete(category);&#10;        await _repo.SaveAsync();&#10;&#10;        return CreateResponse(category, &quot;Categoria excluida com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Category/UpdateCategoryHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Category/UpdateCategoryHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Category;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Category;&#10;&#10;public class UpdateCategoryHandle : CategoryHandlerBase, IRequestHandler&lt;UpdateCategoryCommand, Result&gt;&#10;{&#10;    public UpdateCategoryHandle(ICategoryRepository repo, IMapper mapper) : base(repo, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(UpdateCategoryCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var category = await _repo.GetById(request.CategoryId);&#10;&#10;        if (category is null)&#10;            return CreateError(&quot;Categoria não encontrada para edição&quot;);&#10;&#10;        category = _mapper.Map&lt;CategoryEntity&gt;(request);&#10;&#10;        _repo.Update(category);&#10;        await _repo.SaveAsync();&#10;&#10;        return CreateResponse(category, &quot;Categoria atualizada com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Client/ClientHandlerBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Client/ClientHandlerBase.cs" />
              <option name="updatedContent" value="using StorageStrategy.Domain.Repository;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Client;&#10;&#10;public class ClientHandlerBase : HandlerBase&#10;{&#10;    protected readonly IClientRepository _repo;&#10;&#10;    public ClientHandlerBase(IClientRepository repo)&#10;    {&#10;        _repo = repo;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Client/CreateClientHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Client/CreateClientHandle.cs" />
              <option name="updatedContent" value="using MediatR;&#10;using StorageStrategy.Domain.Commands.Client;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Client;&#10;&#10;public class CreateClientHandle : ClientHandlerBase, IRequestHandler&lt;CreateClientCommand, Result&gt;&#10;{&#10;    public CreateClientHandle(IClientRepository repo) : base(repo)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(CreateClientCommand request, CancellationToken cancellationToken)&#10;    {&#10;        request.Name = request.Name.ToUpper();&#10;        &#10;        var sameNameClient = await _repo.GetByNameAsync(request.CompanyId, request.Name);&#10;        if (sameNameClient is not null)&#10;            return CreateError(&quot;Cliente ja cadastrado com esse nome&quot;);&#10;&#10;        var client = new ClientEntity(request.CompanyId, request.Name);&#10;        client.Active = true;&#10;        await _repo.AddAsync(client);&#10;        await _repo.SaveAsync();&#10;        return CreateResponse(client, &quot;Cliente cadastrado&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Client/GetClientsTotalHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Client/GetClientsTotalHandle.cs" />
              <option name="updatedContent" value="using MediatR;&#10;using StorageStrategy.Domain.Commands;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;using StorageStrategy.Models.ViewModels.Client;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Client;&#10;&#10;public class GetClientsTotalHandle : ClientHandlerBase, IRequestHandler&lt;GetClientsTotalCommandQuery, Result&gt;&#10;{&#10;    public GetClientsTotalHandle(IClientRepository repo) : base(repo)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(GetClientsTotalCommandQuery request, CancellationToken cancellationToken)&#10;    {&#10;        var clients = new List&lt;ClientViewModel&gt;();&#10;        &#10;        var _clientsDb = await _repo.GetAllAsync(p =&gt; p.CompanyId == request.CompanyId);&#10;        &#10;        foreach (var client in _clientsDb)&#10;        {&#10;            clients.Add(new ClientViewModel&#10;            {&#10;                ClientId = client.ClientId,&#10;                Name = client.Name,&#10;                CreateAt = client.CreateAt,&#10;                Active = client.Active,&#10;                TotalCommands = await _repo.GetTotalCommandsAsync(client.ClientId),&#10;            });&#10;        }&#10;        &#10;        return CreateResponse(clients, &quot;Busca realizada&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Client/UpdateClientHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Client/UpdateClientHandle.cs" />
              <option name="updatedContent" value="using MediatR;&#10;using StorageStrategy.Domain.Commands;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Client;&#10;&#10;public class UpdateClientHandle : ClientHandlerBase, IRequestHandler&lt;UpdateClientCommand, Result&gt;&#10;{&#10;    public UpdateClientHandle(IClientRepository repo) : base(repo)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(UpdateClientCommand request, CancellationToken cancellationToken)&#10;    {&#10;        request.Name = request.Name.ToUpper();&#10;&#10;        var client = await _repo.GetById(request.ClientId);&#10;        if (client is null)&#10;            return CreateError(&quot;Cliente não encontrado&quot;);&#10;&#10;        var sameNameClient = await _repo.GetByNameAsync(request.CompanyId, request.Name);&#10;        if (sameNameClient is not null &amp;&amp; sameNameClient.ClientId != request.ClientId)&#10;            return CreateError(&quot;Cliente já cadastrado com esse nome&quot;);&#10;&#10;        client.Name = request.Name;&#10;        client.Active = request.Active;&#10;        _repo.Update(client);&#10;        await _repo.SaveAsync();&#10;        return CreateResponse(client, &quot;Cliente atualizado&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Command/AddProductCommandHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Command/AddProductCommandHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Command;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Command;&#10;&#10;public class AddProductCommandHandle : CommandHandlerBase, IRequestHandler&lt;AddProductCommandCommand, Result&gt;&#10;{&#10;    public AddProductCommandHandle(&#10;        IProductRepository repoProduct,&#10;        ICommandRepository repoCommand,&#10;        IEmployeeRepository employeeRepository,&#10;        IClientRepository clientRepo,&#10;        IMapper mapper) : base(repoProduct, repoCommand, employeeRepository, clientRepo, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(AddProductCommandCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var command = await _repoCommand.GetByIdAsync(request.CommandId);&#10;&#10;        if (command is null)&#10;            return CreateError(&quot;Comando não encontrado&quot;);&#10;&#10;        var product = await _repoProduct.GetByIdAsync(request.ProductId);&#10;&#10;        if (product is null)&#10;            return CreateError(&quot;Produto não encontrado&quot;);&#10;&#10;        if (product.Stock &lt; request.Quantity)&#10;            return CreateError(&quot;Estoque insuficiente&quot;);&#10;&#10;        var commandItem = new CommandItemEntity&#10;        {&#10;            CommandId = request.CommandId,&#10;            ProductId = request.ProductId,&#10;            Quantity = request.Quantity,&#10;            UnitPrice = request.UnitPrice,&#10;            UnitCost = product.Cost&#10;        };&#10;&#10;        command.Items.Add(commandItem);&#10;        product.Stock -= request.Quantity;&#10;&#10;        _repoCommand.Update(command);&#10;        _repoProduct.Update(product);&#10;        await _repoCommand.SaveAsync();&#10;&#10;        return CreateResponse(commandItem, &quot;Produto adicionado ao comando&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Command/CommandHandlerBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Command/CommandHandlerBase.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using StorageStrategy.Domain.Repository;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Command;&#10;&#10;public class CommandHandlerBase : HandlerBase&#10;{&#10;    protected readonly IProductRepository _repoProduct;&#10;    protected readonly ICommandRepository _repoCommand;&#10;    protected readonly IEmployeeRepository _repoEmployee;&#10;    protected readonly IMapper _mapper;&#10;    protected readonly IClientRepository _clientRepo;&#10;&#10;    public CommandHandlerBase(&#10;        IProductRepository repoProduct,&#10;        ICommandRepository repoCommand,&#10;        IEmployeeRepository employeeRepository,&#10;        IClientRepository clientRepo,&#10;        IMapper mapper)&#10;    {&#10;        _repoProduct = repoProduct;&#10;        _mapper = mapper;&#10;        _repoCommand = repoCommand;&#10;        _repoEmployee = employeeRepository;&#10;        _clientRepo = clientRepo;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Command/CreateCommandHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Command/CreateCommandHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Command;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Command;&#10;&#10;public class CreateCommandHandle : CommandHandlerBase, IRequestHandler&lt;CreateCommandCommand, Result&gt;&#10;{&#10;    public CreateCommandHandle(&#10;        IProductRepository repoProduct,&#10;        ICommandRepository repoCommand,&#10;        IEmployeeRepository employeeRepository,&#10;        IClientRepository clientRepo,&#10;        IMapper mapper) : base(repoProduct, repoCommand, employeeRepository, clientRepo, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(CreateCommandCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalido&quot;);&#10;&#10;        var employee = await _repoEmployee.GetByIdAsync(request.EmployeeId, request.CompanyId);&#10;&#10;        if (employee is null)&#10;            return CreateError(&quot;Funcionario não encontrado&quot;);&#10;&#10;        var command = request.CreateCommand();&#10;        &#10;        command.InitialDate = DateTime.Now.AddHours(-3);&#10;&#10;        await _repoCommand.AddAsync(command);&#10;        await _repoCommand.SaveAsync();&#10;&#10;        return CreateResponse(command, &quot;Comando criado com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Command/DeleteCommandHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Command/DeleteCommandHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Command;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Command;&#10;&#10;public class DeleteCommandHandle : CommandHandlerBase, IRequestHandler&lt;DeleteCommandCommand, Result&gt;&#10;{&#10;    public DeleteCommandHandle(&#10;        IProductRepository repoProduct,&#10;        ICommandRepository repoCommand,&#10;        IEmployeeRepository employeeRepository,&#10;        IClientRepository clientRepo,&#10;        IMapper mapper) : base(repoProduct, repoCommand, employeeRepository, clientRepo, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(DeleteCommandCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var command = await _repoCommand.GetByIdAsync(request.CommandId);&#10;&#10;        if (command is null)&#10;            return CreateError(&quot;Comando não encontrado&quot;);&#10;&#10;        if (command.FinalDate.HasValue)&#10;            return CreateError(&quot;Não é possível excluir um comando finalizado&quot;);&#10;&#10;        // Reverter o estoque dos produtos&#10;        foreach (var item in command.Items)&#10;        {&#10;            var product = await _repoProduct.GetByIdAsync(item.ProductId);&#10;            if (product is not null)&#10;            {&#10;                product.Stock += item.Quantity;&#10;                _repoProduct.Update(product);&#10;            }&#10;        }&#10;&#10;        _repoCommand.Delete(command);&#10;        await _repoCommand.SaveAsync();&#10;&#10;        return CreateResponse(command, &quot;Comando excluído com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Command/FinishCommandHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Command/FinishCommandHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Command;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;using StorageStrategy.Utils.Helpers;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Command;&#10;&#10;public class FinishCommandHandle : CommandHandlerBase, IRequestHandler&lt;FinishCommandCommand, Result&gt;&#10;{&#10;    public FinishCommandHandle(&#10;        IProductRepository repoProduct,&#10;        ICommandRepository repoCommand,&#10;        IEmployeeRepository employeeRepository,&#10;        IClientRepository clientRepo,&#10;        IMapper mapper) : base(repoProduct, repoCommand, employeeRepository, clientRepo, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(FinishCommandCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var command = await _repoCommand.GetByIdAsync(request.CommandId);&#10;&#10;        if (command is null)&#10;            return CreateError(&quot;Comando não encontrado&quot;);&#10;&#10;        if (command.Items.Count == 0)&#10;            return CreateError(&quot;Não é possível finalizar um comando sem itens&quot;);&#10;&#10;        command.FinalDate = DateTime.Now.AddHours(-3);&#10;        command.TotalPrice = Calc.TotalPrice(command.Items);&#10;        command.TotalCost = Calc.TotalCost(command.Items);&#10;        command.Discount = request.Discount;&#10;        command.Increase = request.Increase;&#10;        command.Observation = request.Observation;&#10;&#10;        foreach (var payment in request.Payments)&#10;        {&#10;            command.Payments.Add(new PaymentEntity&#10;            {&#10;                Value = payment.Value,&#10;                PaymentType = payment.PaymentType,&#10;                CommandId = command.CommandId&#10;            });&#10;        }&#10;&#10;        _repoCommand.Update(command);&#10;        await _repoCommand.SaveAsync();&#10;&#10;        return CreateResponse(command, &quot;Comando finalizado com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Command/RemoveProductCommandHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Command/RemoveProductCommandHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Command;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Command;&#10;&#10;public class RemoveProductCommandHandle : CommandHandlerBase, IRequestHandler&lt;RemoveProductCommandCommand, Result&gt;&#10;{&#10;    public RemoveProductCommandHandle(&#10;        IProductRepository repoProduct,&#10;        ICommandRepository repoCommand,&#10;        IEmployeeRepository employeeRepository,&#10;        IClientRepository clientRepo,&#10;        IMapper mapper) : base(repoProduct, repoCommand, employeeRepository, clientRepo, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(RemoveProductCommandCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var command = await _repoCommand.GetByIdAsync(request.CommandId);&#10;&#10;        if (command is null)&#10;            return CreateError(&quot;Comando não encontrado&quot;);&#10;&#10;        var commandItem = command.Items.FirstOrDefault(x =&gt; x.CommandItemId == request.CommandItemId);&#10;&#10;        if (commandItem is null)&#10;            return CreateError(&quot;Item não encontrado no comando&quot;);&#10;&#10;        var product = await _repoProduct.GetByIdAsync(commandItem.ProductId);&#10;&#10;        if (product is not null)&#10;        {&#10;            product.Stock += commandItem.Quantity;&#10;            _repoProduct.Update(product);&#10;        }&#10;&#10;        command.Items.Remove(commandItem);&#10;        _repoCommand.Update(command);&#10;        await _repoCommand.SaveAsync();&#10;&#10;        return CreateResponse(commandItem, &quot;Produto removido do comando&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Company/CompanyHandlerBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Company/CompanyHandlerBase.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using StorageStrategy.Domain.Repository;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Company;&#10;&#10;public class CompanyHandlerBase : HandlerBase&#10;{&#10;    protected readonly ICompanyRepository _repository;&#10;    protected readonly IEmployeeRepository _employeeRepository;&#10;    protected readonly IMapper _mapper;&#10;&#10;    public CompanyHandlerBase(ICompanyRepository repository, IMapper mapper, IEmployeeRepository employeeRepository)&#10;    {&#10;        _employeeRepository = employeeRepository;&#10;        _mapper = mapper;&#10;        _repository = repository;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Company/CreateCompanyHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Company/CreateCompanyHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using Isopoh.Cryptography.Argon2;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Company;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;using StorageStrategy.Utils.Helpers;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Company;&#10;&#10;public class CreateCompanyHandle : CompanyHandlerBase, IRequestHandler&lt;CreateCompanyCommand, Result&gt;&#10;{&#10;    public CreateCompanyHandle(ICompanyRepository repository, IMapper mapper, IEmployeeRepository employeeRepository) &#10;        : base(repository, mapper, employeeRepository)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(CreateCompanyCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if(!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados inválidos&quot;);&#10;&#10;        var company = _mapper.Map&lt;CompanyEntity&gt;(request);&#10;&#10;        await _repository.AddAsync(company);&#10;        await _repository.SaveAsync();&#10;&#10;        await CreateUserCompanyAdmin(request.AdminUserName, request.AdminUserEmail, request.Password, company.CompanyId);&#10;        await _repository.CreateCompanyExpenseCategorys(InitialData.GetExpensesCategories(company.CompanyId));&#10;        &#10;        await _repository.SaveAsync();&#10;&#10;        return CreateResponse(company, &quot;Empresa cadastrada com sucesso.&quot;);&#10;    }&#10;&#10;    private async Task CreateUserCompanyAdmin(string name, string email, string password, int companyId)&#10;    {&#10;        var admin = new EmployeeEntity&#10;        {&#10;            Name = name,&#10;            Email = email,&#10;            PasswordHash = Argon2.Hash(password),&#10;            CompanyId = companyId,&#10;            IsAdmin = true&#10;        };&#10;&#10;        await _employeeRepository.AddAsync(admin);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Company/InactivateCompanyHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Company/InactivateCompanyHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Company;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Company;&#10;&#10;public class InactivateCompanyHandle : CompanyHandlerBase, IRequestHandler&lt;InactivateCompanyCommand, Result&gt;&#10;{&#10;    public InactivateCompanyHandle(ICompanyRepository repository, IMapper mapper, IEmployeeRepository employeeRepository) &#10;        : base(repository, mapper, employeeRepository)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(InactivateCompanyCommand request, CancellationToken cancellationToken)&#10;    {&#10;        var company = await _repository.GetById(request.CompanyId);&#10;        &#10;        if (company is null)&#10;            return CreateError(&quot;Empresa não encontrada&quot;);&#10;            &#10;        company.IsActive = false;&#10;        _repository.Update(company);&#10;        await _repository.SaveAsync();&#10;&#10;        return CreateResponse(company, &quot;Empresa inativada com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Company/RenovateCompanyHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Company/RenovateCompanyHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Company;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Company;&#10;&#10;public class RenovateCompanyHandle : CompanyHandlerBase, IRequestHandler&lt;RenovateCompanyCommand, Result&gt;&#10;{&#10;    public RenovateCompanyHandle(ICompanyRepository repository, IMapper mapper, IEmployeeRepository employeeRepository) &#10;        : base(repository, mapper, employeeRepository)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(RenovateCompanyCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados inválidos&quot;);&#10;&#10;        var company = await _repository.GetById(request.CompanyId);&#10;        &#10;        if (company is null)&#10;            return CreateError(&quot;Empresa não encontrada&quot;);&#10;&#10;        company.Validate = request.NewValidateDate;&#10;        company.IsActive = true;&#10;        &#10;        _repository.Update(company);&#10;        await _repository.SaveAsync();&#10;&#10;        return CreateResponse(company, &quot;Licença da empresa renovada com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Employee/CreateEmployeeHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Employee/CreateEmployeeHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using Isopoh.Cryptography.Argon2;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Employee;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Employee;&#10;&#10;public class CreateEmployeeHandle : EmployeeHandlerBase, IRequestHandler&lt;CreateEmployeeCommand, Result&gt;&#10;{&#10;    public CreateEmployeeHandle(IEmployeeRepository repo, IMapper mapper) : base(repo, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(CreateEmployeeCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var employee = await _repo.FindByName(request.Name, request.CompanyId);&#10;&#10;        if (employee is not null)&#10;            return CreateError(&quot;Ja existe um funcionário com esse nome&quot;);&#10;&#10;        employee = _mapper.Map&lt;EmployeeEntity&gt;(request);&#10;        employee.PasswordHash = Argon2.Hash(request.Password);&#10;        &#10;        await _repo.AddAsync(employee);&#10;        await _repo.SaveAsync();&#10;&#10;        return CreateResponse(employee, &quot;Funcionario cadastrado com sucesso.&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Employee/DeleteEmployeeHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Employee/DeleteEmployeeHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Employee;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Employee;&#10;&#10;public class DeleteEmployeeHandle : EmployeeHandlerBase, IRequestHandler&lt;DeleteEmployeeCommand, Result&gt;&#10;{&#10;    public DeleteEmployeeHandle(IEmployeeRepository repo, IMapper mapper) : base(repo, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(DeleteEmployeeCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var employee = await _repo.GetByIdAsync(request.EmployeeId, request.CompanyId);&#10;&#10;        if (employee is null)&#10;            return CreateError(&quot;Funcionário não encontrado para exclusão&quot;);&#10;&#10;        if (employee.IsAdmin)&#10;            return CreateError(&quot;Não é possível excluir um funcionário administrador&quot;);&#10;&#10;        _repo.Delete(employee);&#10;        await _repo.SaveAsync();&#10;&#10;        return CreateResponse(employee, &quot;Funcionário excluído com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Employee/EmployeeHandlerBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Employee/EmployeeHandlerBase.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using StorageStrategy.Domain.Repository;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Employee;&#10;&#10;public class EmployeeHandlerBase : HandlerBase&#10;{&#10;    protected readonly IEmployeeRepository _repo;&#10;    protected readonly IMapper _mapper;&#10;&#10;    public EmployeeHandlerBase(IEmployeeRepository repo, IMapper mapper)&#10;    {&#10;        _repo = repo;&#10;        _mapper = mapper;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Employee/UpdateEmployeeHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Employee/UpdateEmployeeHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Employee;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Employee;&#10;&#10;public class UpdateEmployeeHandle : EmployeeHandlerBase, IRequestHandler&lt;UpdateEmployeeCommand, Result&gt;&#10;{&#10;    public UpdateEmployeeHandle(IEmployeeRepository repo, IMapper mapper) : base(repo, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(UpdateEmployeeCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var employee = await _repo.GetByIdAsync(request.EmployeeId, request.CompanyId);&#10;&#10;        if (employee is null)&#10;            return CreateError(&quot;Funcionário não encontrado para edição&quot;);&#10;&#10;        employee.Name = request.Name;&#10;        employee.Email = request.Email;&#10;        employee.IsAdmin = request.IsAdmin;&#10;&#10;        _repo.Update(employee);&#10;        await _repo.SaveAsync();&#10;&#10;        return CreateResponse(employee, &quot;Funcionário atualizado com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Expenses/CreateExpenseHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Expenses/CreateExpenseHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Expenses;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Expenses;&#10;&#10;public class CreateExpenseHandle : ExpensesHandlerBase, IRequestHandler&lt;CreateExpenseCommand, Result&gt;&#10;{&#10;    public CreateExpenseHandle(IExpenseRepository repo, IMapper mapper) : base(repo, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(CreateExpenseCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var expenses = _mapper.Map&lt;ExpenseEntity&gt;(request);&#10;&#10;        await _repo.AddAsync(expenses);&#10;        await _repo.SaveAsync();&#10;&#10;        return CreateResponse(expenses, &quot;Despesa cadastrada com sucesso.&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Expenses/CreateExpenseTypeHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Expenses/CreateExpenseTypeHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Expenses;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Expenses;&#10;&#10;public class CreateExpenseTypeHandle : ExpensesHandlerBase, IRequestHandler&lt;CreateExpenseTypeCommand, Result&gt;&#10;{&#10;    public CreateExpenseTypeHandle(IExpenseRepository repo, IMapper mapper) : base(repo, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(CreateExpenseTypeCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var expenseType = _mapper.Map&lt;ExpensesTypeEntity&gt;(request);&#10;&#10;        await _repo.AddExpenseTypeAsync(expenseType);&#10;        await _repo.SaveAsync();&#10;&#10;        return CreateResponse(expenseType, &quot;Tipo de despesa cadastrado com sucesso.&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Expenses/DeleteExpenseHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Expenses/DeleteExpenseHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Expenses;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Expenses;&#10;&#10;public class DeleteExpenseHandle : ExpensesHandlerBase, IRequestHandler&lt;DeleteExpenseCommand, Result&gt;&#10;{&#10;    public DeleteExpenseHandle(IExpenseRepository repo, IMapper mapper) : base(repo, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(DeleteExpenseCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var expenses = await _repo.GetExpensesByIdAsync(request.ExpenseId, request.CompanyId);&#10;&#10;        if (expenses is null)&#10;            return CreateError(&quot;Essa despesa não existe&quot;);&#10;&#10;        _repo.Delete(expenses);&#10;        await _repo.SaveAsync();&#10;&#10;        return CreateResponse(expenses, &quot;Despesa excluída com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Expenses/DeleteExpenseTypeHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Expenses/DeleteExpenseTypeHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Expenses;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Expenses;&#10;&#10;public class DeleteExpenseTypeHandle : ExpensesHandlerBase, IRequestHandler&lt;DeleteExpenseTypeCommand, Result&gt;&#10;{&#10;    public DeleteExpenseTypeHandle(IExpenseRepository repo, IMapper mapper) : base(repo, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(DeleteExpenseTypeCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var expenseType = await _repo.GetExpenseTypeByIdAsync(request.ExpenseTypeId, request.CompanyId);&#10;&#10;        if (expenseType is null)&#10;            return CreateError(&quot;Tipo de despesa não encontrado&quot;);&#10;&#10;        _repo.DeleteExpenseType(expenseType);&#10;        await _repo.SaveAsync();&#10;&#10;        return CreateResponse(expenseType, &quot;Tipo de despesa excluído com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Expenses/ExpensesHandlerBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Expenses/ExpensesHandlerBase.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using StorageStrategy.Domain.Repository;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Expenses;&#10;&#10;public class ExpensesHandlerBase : HandlerBase&#10;{&#10;    protected readonly IExpenseRepository _repo;&#10;    protected readonly IMapper _mapper;&#10;&#10;    public ExpensesHandlerBase(IExpenseRepository repo, IMapper mapper)&#10;    {&#10;        _repo = repo;&#10;        _mapper = mapper;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Product/CreateProductHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Product/CreateProductHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Products;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Product;&#10;&#10;public class CreateProductHandle : ProductHandlerBase, IRequestHandler&lt;CreateProductCommand, Result&gt;&#10;{&#10;    public CreateProductHandle(IProductRepository repo, ICategoryRepository repoCategory, IMapper mapper) : base(repo, repoCategory, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(CreateProductCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var product = await _repo.FindByName(request.Name, request.CompanyId);&#10;            &#10;        if (product is not null)&#10;            return CreateError(&quot;Ja existe um produto com esse nome&quot;);&#10;&#10;        var category = await _repoCategory.GetById(request.CategoryId);&#10;&#10;        if (category is null)&#10;            return CreateError(&quot;Categoria não encontrada&quot;);&#10;&#10;        product = _mapper.Map&lt;ProductEntity&gt;(request);&#10;&#10;        await _repo.AddAsync(product);&#10;        await _repo.SaveAsync();&#10;&#10;        return CreateResponse(product, &quot;Produto cadastrado com sucesso.&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Product/CreateStockHistoryHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Product/CreateStockHistoryHandle.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.StockHistory;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Product;&#10;&#10;public class CreateStockHistoryHandle : ProductHandlerBase, IRequestHandler&lt;CreateStockHsitoryCommand, Result&gt;&#10;{&#10;    public CreateStockHistoryHandle(IProductRepository repo, ICategoryRepository repoCategory, IMapper mapper) : base(repo, repoCategory, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(CreateStockHsitoryCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var stockHistory = new StockHistoryEntity&#10;        {&#10;            CompanyId = request.CompanyId,&#10;            CreatedAt = DateTime.Now.AddHours(-3),&#10;            Items = new List&lt;StockHistoryItemEntity&gt;()&#10;        };&#10;&#10;        foreach (var item in request.Products)&#10;        {&#10;            var product = await _repo.GetByIdAsync(item.ProductId);&#10;            &#10;            if (product is null)&#10;            {&#10;                return CreateError($&quot;Produto não encontrado: {item.ProductId}&quot;);&#10;            }&#10;&#10;            // Atualizar estoque do produto&#10;            product.Quantity += item.Quantity;&#10;            _repo.Update(product);&#10;&#10;            // Adicionar item ao histórico&#10;            stockHistory.Items.Add(new StockHistoryItemEntity&#10;            {&#10;                ProductId = item.ProductId,&#10;                Quantity = item.Quantity,&#10;                Cost = item.Cost&#10;            });&#10;        }&#10;&#10;        await _repo.AddAsync(stockHistory);&#10;        await _repo.SaveAsync();&#10;&#10;        return CreateResponse(stockHistory, &quot;Histórico de estoque criado com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Product/DeleteProductHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Product/DeleteProductHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Products;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Product;&#10;&#10;public class DeleteProductHandle : ProductHandlerBase, IRequestHandler&lt;DeleteProductCommand, Result&gt;&#10;{&#10;    public DeleteProductHandle(IProductRepository repo, ICategoryRepository repoCategory, IMapper mapper) : base(repo, repoCategory, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(DeleteProductCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var product = await _repo.GetByIdAsync(request.ProductId);&#10;&#10;        if (product is null)&#10;            return CreateError(&quot;Produto não encontrado para exclusão&quot;);&#10;&#10;        _repo.Delete(product);&#10;        await _repo.SaveAsync();&#10;&#10;        return CreateResponse(product, &quot;Produto excluído com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Product/ImportProductHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Product/ImportProductHandle.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using System.Globalization;&#10;using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Products;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Product;&#10;&#10;public class ImportProductHandle : ProductHandlerBase, IRequestHandler&lt;ImportProductCommand, Result&gt;&#10;{&#10;    public ImportProductHandle(IProductRepository repo, ICategoryRepository repoCategory, IMapper mapper) : base(repo, repoCategory, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(ImportProductCommand request, CancellationToken cancellationToken)&#10;    {&#10;        var importedProducts = new List&lt;ProductEntity&gt;();&#10;        var errors = new List&lt;string&gt;();&#10;&#10;        foreach (var productData in request.Products)&#10;        {&#10;            try&#10;            {&#10;                // Verificar se produto já existe&#10;                var existingProduct = await _repo.FindByName(productData.Name, request.CompanyId);&#10;                if (existingProduct is not null)&#10;                {&#10;                    errors.Add($&quot;Produto já existe: {productData.Name}&quot;);&#10;                    continue;&#10;                }&#10;&#10;                var product = new ProductEntity&#10;                {&#10;                    Name = productData.Name,&#10;                    Price = productData.Price,&#10;                    Cost = productData.Cost,&#10;                    CompanyId = request.CompanyId,&#10;                    CategoryId = productData.CategoryId&#10;                };&#10;&#10;                await _repo.AddAsync(product);&#10;                importedProducts.Add(product);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                errors.Add($&quot;Erro ao processar produto '{productData.Name}': {ex.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        if (importedProducts.Any())&#10;        {&#10;            await _repo.SaveAsync();&#10;        }&#10;&#10;        var result = new&#10;        {&#10;            ImportedCount = importedProducts.Count,&#10;            ImportedProducts = importedProducts,&#10;            Errors = errors&#10;        };&#10;&#10;        return CreateResponse(result, $&quot;Importação concluída. {importedProducts.Count} produtos importados.&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Product/ProductHandlerBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Product/ProductHandlerBase.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using StorageStrategy.Domain.Repository;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Product;&#10;&#10;public class ProductHandlerBase : HandlerBase&#10;{&#10;    protected readonly IProductRepository _repo;&#10;    protected readonly ICategoryRepository _repoCategory;&#10;    protected readonly IMapper _mapper;&#10;&#10;    public ProductHandlerBase(IProductRepository repo, ICategoryRepository repoCategory, IMapper mapper)&#10;    {&#10;        _repo = repo;&#10;        _mapper = mapper;&#10;        _repoCategory = repoCategory;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Product/UpdateProductHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Product/UpdateProductHandle.cs" />
              <option name="updatedContent" value="using AutoMapper;&#10;using MediatR;&#10;using StorageStrategy.Domain.Commands.Products;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Product;&#10;&#10;public class UpdateProductHandle : ProductHandlerBase, IRequestHandler&lt;UpdateProductCommand, Result&gt;&#10;{&#10;    public UpdateProductHandle(IProductRepository repo, ICategoryRepository repoCategory, IMapper mapper) : base(repo, repoCategory, mapper)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(UpdateProductCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var product = await _repo.GetByIdAsync(request.ProductId);&#10;&#10;        if (product is null)&#10;            return CreateError(&quot;Produto não encontrado para edição&quot;);&#10;&#10;        var category = await _repoCategory.GetById(request.CategoryId);&#10;&#10;        if (category is null)&#10;            return CreateError(&quot;Categoria não encontrada&quot;);&#10;&#10;        var existingProduct = await _repo.FindByName(request.Name, request.CompanyId);&#10;        if (existingProduct is not null &amp;&amp; existingProduct.ProductId != request.ProductId)&#10;            return CreateError(&quot;Já existe um produto com esse nome&quot;);&#10;&#10;        product.Name = request.Name;&#10;        product.Description = request.Description;&#10;        product.Price = request.Price;&#10;        product.Cost = request.Cost;&#10;        product.CategoryId = request.CategoryId;&#10;&#10;        _repo.Update(product);&#10;        await _repo.SaveAsync();&#10;&#10;        return CreateResponse(product, &quot;Produto atualizado com sucesso&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Report/ReadCommandsBetweenDatesHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Report/ReadCommandsBetweenDatesHandle.cs" />
              <option name="updatedContent" value="using MediatR;&#10;using StorageStrategy.Domain.Commands.Report;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Report;&#10;&#10;public class ReadCommandsBetweenDatesHandle : ReportHandlerBase, IRequestHandler&lt;ReadCommandsBetweenDatesCommand, Result&gt;&#10;{&#10;    public ReadCommandsBetweenDatesHandle(IReportRepository repo) : base(repo)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(ReadCommandsBetweenDatesCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;            &#10;        request.FinalDate = request.FinalDate.AddDays(1);&#10;        var commands = await _repo.ReadCommandsByDateAsync(request);&#10;        &#10;        return CreateResponse(new {&#10;            Commands = commands,&#10;            TotalCost = commands.Sum(p =&gt; p.TotalCost),&#10;            TotalPrice = commands.Sum(p =&gt; p.TotalPrice - p.Discount + p.Increase),&#10;        }, &quot;Busca realizada !&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Report/ReadCommandsByMounthHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Report/ReadCommandsByMounthHandle.cs" />
              <option name="updatedContent" value="using MediatR;&#10;using StorageStrategy.Domain.Commands.Report;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Report;&#10;&#10;public class ReadCommandsByMounthHandle : ReportHandlerBase, IRequestHandler&lt;ReadCommandsByMounthCommand, Result&gt;&#10;{&#10;    public ReadCommandsByMounthHandle(IReportRepository repo) : base(repo)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(ReadCommandsByMounthCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var commands = await _repo.ReadCommandsByMounthAsync(request.CompanyId, request.Month, request.EmployeeId);&#10;&#10;        return CreateResponse(new&#10;        {&#10;            Commands = commands,&#10;            TotalCost = commands.Sum(p =&gt; p.TotalCost),&#10;            TotalPrice = commands.Sum(p =&gt; p.TotalPrice),&#10;        }, &quot;Busca realizada !&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Report/ReadPaymentCommandHandle.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Report/ReadPaymentCommandHandle.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using MediatR;&#10;using StorageStrategy.Domain.Commands.Report;&#10;using StorageStrategy.Domain.Repository;&#10;using StorageStrategy.Models;&#10;using StorageStrategy.Utils.Helpers;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Report;&#10;&#10;public class ReadPaymentCommandHandle : ReportHandlerBase, IRequestHandler&lt;ReadPaymentCommandCommand, Result&gt;&#10;{&#10;    public ReadPaymentCommandHandle(IReportRepository repo) : base(repo)&#10;    {&#10;    }&#10;&#10;    public async Task&lt;Result&gt; Handle(ReadPaymentCommandCommand request, CancellationToken cancellationToken)&#10;    {&#10;        if (!request.IsValid())&#10;            return CreateError(request.GetErros(), &quot;Dados invalidos&quot;);&#10;&#10;        var commands = await _repo.ReadCommandsByMounthAsync(request.CompanyId, request.Month, null);&#10;&#10;        var result = new&#10;        {&#10;            TotalPix = Calc.CountSalesPayment(commands, PaymentEnum.Pix),&#10;            TotalDebit = Calc.CountSalesPayment(commands, PaymentEnum.Debit),&#10;            TotalCredit = Calc.CountSalesPayment(commands, PaymentEnum.Credit),&#10;            TotalCash = Calc.CountSalesPayment(commands, PaymentEnum.Cash),&#10;            Total = commands.SelectMany(p =&gt; p.Payments).Count()&#10;        };&#10;&#10;        return CreateResponse(result, &quot;Busca realizada !&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Report/ReportHandlerBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorageStrategy.Domain/Handlers/Report/ReportHandlerBase.cs" />
              <option name="updatedContent" value="using StorageStrategy.Domain.Repository;&#10;&#10;namespace StorageStrategy.Domain.Handlers.Report;&#10;&#10;public class ReportHandlerBase : HandlerBase&#10;{&#10;    protected readonly IReportRepository _repo;&#10;&#10;    public ReportHandlerBase(IReportRepository repo)&#10;    {&#10;        _repo = repo;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>